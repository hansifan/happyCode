# 小易有一些彩色的砖块。每种颜色由一个大写字母表示。各个颜色砖块看起来都完全一样。现在有一个给定的字符串s,s中每个字符代表小易的某个砖块的颜色。小易想把他所有的砖块排成一行。如果最多存在一对不同颜色的相邻砖块,那么这行砖块就很漂亮的。请你帮助小易计算有多少种方式将他所有砖块排成漂亮的一行。(如果两种方式所对应的砖块颜色序列是相同的,那么认为这两种方式是一样的。)
# 例如: s = "ABAB",那么小易有六种排列的结果:
# "AABB","ABAB","ABBA","BAAB","BABA","BBAA"
# 其中只有"AABB"和"BBAA"满足最多只有一对不同颜色的相邻砖块。 

#输入例子 ABAB
#输出例子 2

string = str(input(''))

#字符串切片
list_test = []
for i in range(1,len(string)+1):
  list_test.append(string[i-1:i])

#字符串去重
new_list = []
for i in list_test:
    if i not in new_list:
        new_list.append(i)


# 这个题千万不要被这个全排列蒙蔽了，然后傻乎乎的去字母计算全排列，笔试时间有限，肯定有简单的方法。
# 分析一下：如果只有一种大写字母，肯定只有一种情况；
# 如果有两种大写字母，全排列出来有6中，符合题意的肯定只有两种；
# 如果有三种字母（或者>3种），不同字母紧靠且符合题意的肯定没有；
# 所以，显而易见，三种情况考虑就OK了。
size = 0
size = len(new_list)
if size == 2:
    print(2)
elif size == 1:
    print(1)
else:
    print(0)
